# Ghidra headless script to export decompiled PEX/I2C-related functions.
#
# Usage:
#   analyzeHeadless <project_dir> <project_name> \
#     -process fullfw -noanalysis \
#     -postScript ghidra_export_pex_functions.py <output_dir>
#
# The script decompiles all functions matching PEX/I2C patterns and writes
# individual .c files plus an INDEX.md summary.
#
# @category Analysis
# @runtime Jython

import os
import re

from ghidra.app.decompiler import DecompInterface
from ghidra.util.task import ConsoleTaskMonitor

# ---------------------------------------------------------------------------
# Configuration: function name patterns to export
# ---------------------------------------------------------------------------

# Exact prefixes (case-insensitive)
PREFIXES = [
    "pex8696_",
    "pex8647_",
    "gpu_power_on_",
    "multi_host_mode_",
    "all_slot_power_off",
    "pex8696_slot_power_on",
    "pex8696_slot_power_ctrl",
]

# Exact names (case-insensitive)
EXACT_NAMES = [
    "PI2CWriteRead",
    "PI2CMuxWriteRead",
    "write_pex8696_register",
    "read_pex8696_register",
    "write_pex8647_register",
    "read_pex8647_register",
    "get_PEX8696_addr_port",
    "Start_GPU_Power_Sequence",
    "read_pex_register",
    "write_pex_register",
    "read_plx_eeprom",
    "write_plx_eeprom",
    "dump_PEX8696_reg",
]


def should_export(name):
    """Check if a function name matches any of our export patterns."""
    lower = name.lower()
    for prefix in PREFIXES:
        if lower.startswith(prefix.lower()):
            return True
    for exact in EXACT_NAMES:
        if lower == exact.lower():
            return True
    return False


def main():
    args = getScriptArgs()
    if len(args) < 1:
        println("ERROR: Output directory argument required")
        println("Usage: -postScript ghidra_export_pex_functions.py <output_dir>")
        return

    output_dir = args[0]

    # Create output directory if it doesn't exist
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    println("=" * 70)
    println("Ghidra PEX/I2C Function Decompiler Export")
    println("=" * 70)
    println("Output directory: %s" % output_dir)

    # Set up the decompiler
    decomp = DecompInterface()
    decomp.openProgram(currentProgram)
    monitor = ConsoleTaskMonitor()

    # Collect matching functions
    fm = currentProgram.getFunctionManager()
    matching_functions = []

    for func in fm.getFunctions(True):  # True = forward iteration
        name = func.getName()
        if should_export(name):
            matching_functions.append(func)

    println("Found %d matching functions" % len(matching_functions))
    println("-" * 70)

    # Decompile each function and write to file
    exported = []
    failed = []

    for func in sorted(matching_functions, key=lambda f: f.getName().lower()):
        name = func.getName()
        entry = func.getEntryPoint()
        body = func.getBody()
        size = body.getNumAddresses()

        println("Decompiling: %s @ 0x%s (size: %d bytes)" % (
            name, entry.toString(), size))

        results = decomp.decompileFunction(func, 120, monitor)

        if results.decompileCompleted():
            decomp_func = results.getDecompiledFunction()
            if decomp_func is not None:
                c_code = decomp_func.getC()
                signature = decomp_func.getSignature()

                # Write the .c file with a header comment
                c_filepath = os.path.join(output_dir, "%s.c" % name)
                with open(c_filepath, "w") as f:
                    f.write("/* Decompiled from Dell C410X BMC firmware (fullfw)\n")
                    f.write(" * Function: %s\n" % name)
                    f.write(" * Address:  0x%s\n" % entry.toString())
                    f.write(" * Size:     %d bytes\n" % size)
                    f.write(" *\n")
                    f.write(" * Auto-generated by Ghidra %s\n" % (
                        currentProgram.getCompilerSpec().getCompilerSpecDescription().toString()
                        if hasattr(currentProgram.getCompilerSpec(), 'getCompilerSpecDescription')
                        else "headless decompiler"))
                    f.write(" */\n\n")
                    f.write(c_code)

                exported.append({
                    "name": name,
                    "address": "0x%s" % entry.toString(),
                    "size": size,
                    "signature": signature if signature else "N/A",
                    "file": "%s.c" % name,
                })
                println("  -> Exported to %s.c" % name)
            else:
                failed.append({
                    "name": name,
                    "address": "0x%s" % entry.toString(),
                    "reason": "Decompiler returned null function",
                })
                println("  -> FAILED: null decompiled function")
        else:
            error_msg = results.getErrorMessage()
            failed.append({
                "name": name,
                "address": "0x%s" % entry.toString(),
                "reason": error_msg if error_msg else "Unknown error",
            })
            println("  -> FAILED: %s" % (error_msg if error_msg else "Unknown error"))

    # Write INDEX.md
    println("-" * 70)
    println("Writing INDEX.md...")

    index_path = os.path.join(output_dir, "INDEX.md")
    with open(index_path, "w") as f:
        f.write("# Decompiled PEX/I2C Functions\n\n")
        f.write("Decompiled from Dell C410X BMC firmware (`fullfw` ARM ELF binary).\n\n")
        f.write("## Summary\n\n")
        f.write("- **Total exported:** %d functions\n" % len(exported))
        f.write("- **Failed:** %d functions\n" % len(failed))
        f.write("- **Binary:** fullfw (ARM 32-bit LE, not stripped)\n")
        f.write("- **Processor:** ARM:LE:32:v5t (ARM926EJ-S / ARMv5TEJ)\n\n")

        # Group functions by category
        categories = {
            "I2C Transport": [],
            "PEX8696 Register Access": [],
            "PEX8647 Register Access": [],
            "PEX Address Mapping": [],
            "PEX8696 Hot-Plug Control": [],
            "PEX8696 Slot Power": [],
            "PEX8696 Multi-Host": [],
            "PEX8696 Configuration": [],
            "PEX8647 Functions": [],
            "GPU Power Sequencing": [],
            "PLX EEPROM": [],
            "PEX Register Dump": [],
            "Other": [],
        }

        for entry in exported:
            name = entry["name"]
            lower = name.lower()
            if lower in ("pi2cwriteread", "pi2cmuxwriteread"):
                categories["I2C Transport"].append(entry)
            elif lower in ("write_pex8696_register", "read_pex8696_register"):
                categories["PEX8696 Register Access"].append(entry)
            elif lower in ("write_pex8647_register", "read_pex8647_register"):
                categories["PEX8647 Register Access"].append(entry)
            elif lower in ("get_pex8696_addr_port",):
                categories["PEX Address Mapping"].append(entry)
            elif lower.startswith("pex8696_hp_"):
                categories["PEX8696 Hot-Plug Control"].append(entry)
            elif lower.startswith("pex8696_slot_power") or lower.startswith("all_slot_power"):
                categories["PEX8696 Slot Power"].append(entry)
            elif "multi_host" in lower:
                categories["PEX8696 Multi-Host"].append(entry)
            elif lower.startswith("pex8696_cfg_"):
                categories["PEX8696 Configuration"].append(entry)
            elif lower.startswith("pex8647_"):
                categories["PEX8647 Functions"].append(entry)
            elif lower.startswith("gpu_power_on") or lower == "start_gpu_power_sequence":
                categories["GPU Power Sequencing"].append(entry)
            elif "plx_eeprom" in lower:
                categories["PLX EEPROM"].append(entry)
            elif "dump_pex" in lower:
                categories["PEX Register Dump"].append(entry)
            else:
                categories["Other"].append(entry)

        f.write("## Functions by Category\n\n")
        for cat_name, entries in categories.items():
            if not entries:
                continue
            f.write("### %s\n\n" % cat_name)
            f.write("| Function | Address | Size (bytes) | File |\n")
            f.write("|----------|---------|-------------|------|\n")
            for entry in sorted(entries, key=lambda e: e["name"].lower()):
                f.write("| `%s` | `%s` | %d | [%s](%s) |\n" % (
                    entry["name"], entry["address"], entry["size"],
                    entry["file"], entry["file"]))
            f.write("\n")

        if failed:
            f.write("## Failed Decompilations\n\n")
            f.write("| Function | Address | Reason |\n")
            f.write("|----------|---------|--------|\n")
            for entry in failed:
                f.write("| `%s` | `%s` | %s |\n" % (
                    entry["name"], entry["address"], entry["reason"]))
            f.write("\n")

        f.write("## All Functions (Alphabetical)\n\n")
        f.write("| # | Function | Address | Size (bytes) | File |\n")
        f.write("|---|----------|---------|-------------|------|\n")
        for i, entry in enumerate(sorted(exported, key=lambda e: e["name"].lower()), 1):
            f.write("| %d | `%s` | `%s` | %d | [%s](%s) |\n" % (
                i, entry["name"], entry["address"], entry["size"],
                entry["file"], entry["file"]))

    println("-" * 70)
    println("DONE: Exported %d functions, %d failed" % (len(exported), len(failed)))
    println("Output: %s" % output_dir)
    println("Index:  %s" % index_path)
    println("=" * 70)

    decomp.dispose()


main()
